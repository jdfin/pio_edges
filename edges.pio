.pio_version 0

; This uses one PIO state machine to poll for change on a GPIO line and put a
; tick count of when the GPIO changed into the RX FIFO. Before the tick count
; is written to the FIFO, a '0' is written if it's a falling edge, or a '1' is
; written if it's a rising edge.
;
; The tick count is kept by carefully scheduling decrements to the PIO's X
; register in the polling loop. It decrements (exactly) every four PIO clocks,
; for all code paths, so should be crystal-accurate. The only error introduced
; is by where in the polling loop the GPIO really changed, i.e. there are four
; PIO clocks in the loop, and a GPIO edge on any of those four clocks results
; in the same tick count. If that's a problem, increase the PIO clock rate.
;
; The tick count is a 32-bit down counter. The PIO doesn't have an increment
; instruction, and it's easy enough to convert after reading the timestamp.
;
; The tick resolution is set by changing the PIO clock rate (the "tick_hz"
; parameter to edges_program_init()). For 1 usec resolution, use 1'000'000 for
; tick_hz, or for 0.1 usec resolution, use 10'000'000. I've only tried those
; two values, but anything that evenly divides into sys_clk (200 MHz on my
; Pico) / 4 (PIO clocks per tick) should work fine. I don't know what errors
; (if any) using the fractional part of the clock divider would introduce. It
; would likely be fine.
;
; The CPU code can either poll for the PIO RX FIFO to have data, or trigger an
; interrupt on RX FIFO not empty and read the tick there.
;
; To change this code, you need to know how the PIO works and be ready to
; count clock cycles.

.program edges

.wrap_target

; push 0 to show we're waiting for a falling edge
L0: set  y 0
L1: mov  isr y
L2: jmp  x-- L3
L3: push noblock

; poll for falling edge
L4: nop [1]
L5: jmp  x-- L6
L6: jmp  pin L4

; falling edge detected
L7: mov  isr x [1]
L8: jmp  x-- L9
L9: push noblock [2]

; push 1 to show we're waiting for a rising edge
LA: jmp  x-- LB
LB: set  y 1
LC: mov  isr y
LD: push noblock

; poll for rising edge
LE: jmp  x-- LF
LF: jmp  pin LH [1]
LG: jmp  LE

; rising edge detected
LH: mov  isr x
LI: jmp  x-- LJ
LJ: push noblock

.wrap

; Falling edge, rising edge, falling edge. Things to note:
;
; * The X register always decrements every four cycles. The resolution of the
;   timestamps will be pio_clk / 4, e.g. if pio_clk is 4 MHz, timestamps have
;   1 usec resolution; if pio_clk is 40 HMz, a 0.1 usec resolution.
;
; * A timestamp is available 5 pio_clks after the edge is detected, either
;   rising or falling. This is not very important, but is nice that they are
;   the same.
;
; * The time from a falling edge to the next rising edge, and vice versa, is a
;   multiple of four PIO clocks. This means neither edge will be artificially
;   delayed a clock or two compared to the other.
;
; * Very short pulses will not be detected. If you need to measure very short
;   pulses like that, increase pio_clk.
;
; +-----+----+-----------+-----+-----+------+
; | PIN | PC | INSTR     |  X  | ISR | FIFO |
; +-----+----+-----------+-----+-----+------+
; |  1  |  6 | jmp pin 4 |  9  |     |      |
; |     |  4 | nop       |  9  |     |      |
; |     |    |           |  9  |     |      |
; |     |  5 | jmp x-- 6 |  9  |     |      |
; |  1  |  6 | jmp pin 4 |  8  |     |      |
; |     |  4 | nop       |  8  |     |      |
; |     |    |           |  8  |     |      |
; |     |  5 | jmp x-- 6 |  8  |     |      |
; |  0  |  6 | jmp pin 4 |  7  |     |      | < 0 falling edge detected
; |     |  7 | mov isr x |  7  |     |      |
; |     |    |           |  7  |  7  |      |
; |     |  8 | jmp x-- 9 |  7  |  7  |      |
; |     |  9 | push      |  6  |  7  |      |
; |     |    |           |  6  |     |   7  | < +5 timestamp available
; |     |    |           |  6  |     |      |
; |     |  A | jmp x-- B |  6  |     |      |
; |     |  B | set y 1   |  5  |     |      |
; |     |  C | mov isr y |  5  |     |      |
; |     |  D | push      |  5  |  1  |      |
; |     |  E | jmp x-- F |  5  |     |   1  | < looking for rising edge
; |  0  |  F | jmp pin H |  4  |     |      |
; |     |    |           |  4  |     |      |
; |     |  G | jmp E     |  4  |     |      |
; |     |  E | jmp x-- F |  4  |     |      |
; |  0  |  F | jmp pin H |  3  |     |      |
; |     |    |           |  3  |     |      |
; |     |  G | jmp E     |  3  |     |      |
; |     |  E | jmp x-- F |  3  |     |      |
; |  1  |  F | jmp pin H |  2  |     |      | < +20 rising edge detected
; |     |    |           |  2  |     |      |
; |     |  H | mov isr x |  2  |     |      |
; |     |  I | jmp x-- J |  2  |  2  |      |
; |     |  J | push      |  1  |  2  |      |
; |     |  0 | set y 0   |  1  |     |   2  | < +5 timestamp available
; |     |  1 | mov isr y |  1  |     |      |
; |     |  2 | jmp x-- 3 |  1  |  0  |      |
; |     |  3 | push      |  0  |     |   0  | < looking for falling edge
; |     |  4 | nop       |  0  |     |      |
; |     |    |           |  0  |     |      |
; |     |  5 | jmp x-- 6 |  0  |     |      |
; |  1  |  6 | jmp pin 4 |  9  |     |      |
; |     |  4 | nop       |  9  |     |      |
; |     |    |           |  9  |     |      |
; |     |  5 | jmp x-- 6 |  9  |     |      |
; |  1  |  6 | jmp pin 4 |  8  |     |      |
; |     |  4 | nop       |  8  |     |      |
; |     |    |           |  8  |     |      |
; |     |  5 | jmp x-- 6 |  8  |     |      |
; |  0  |  6 | jmp pin 4 |  7  |     |      | < +20 falling edge detected
; |     |  7 | mov isr x |  7  |     |      |
; |     |    |           |  7  |  7  |      |
; |     |  8 | jmp x-- 9 |  7  |  7  |      |
; |     |  9 | push      |  6  |  7  |      |
; |     |    |           |  6  |     |   7  | < +5 timestamp available
; |     |    |           |  6  |     |      |
; |     |  A | jmp x-- B |  6  |     |      |
; |     |  B | set y 1   |  5  |     |      |
; |     |  C | mov isr y |  5  |     |      |
; |     |  D | push      |  5  |  1  |      |
; |     |  E | jmp x-- F |  5  |     |   1  | < looking for rising edge
; |  0  |  F | jmp pin H |  4  |     |      |
; |     |    |           |  4  |     |      |
; |     |  G | jmp E     |  4  |     |      |
; |     |  E | jmp x-- F |  4  |     |      |
; |  0  |  F | jmp pin H |  3  |     |      |
; |     |    |           |  3  |     |      |
; |     |  G | jmp E     |  3  |     |      |
; |     |  E | jmp x-- F |  3  |     |      |
; +-----+----+-----------+-----+-----+------+

% c-sdk {

// x-register in pio code decrements every this-many clocks (pio code above)
static const uint32_t edges_div = 4;

static inline void edges_program_init(PIO pio, uint sm, uint offset, uint pin, uint tick_hz)
{
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);

    pio_gpio_init(pio, pin);

    pio_sm_config c = edges_program_get_default_config(offset);

    sm_config_set_jmp_pin(&c, pin);

    // clock frequency to pio
    const uint32_t pio_clk_hz = clock_get_hz(clk_sys);

    const uint32_t clk_div = pio_clk_hz / edges_div / tick_hz;

    // for pio_clk_hz = 200 MHz, edges_div = 4,
    //   and tick_hz =  1,000,000, clk_div is 50
    //   and tick_hz = 10,000,000, clk_div is 5

    sm_config_set_clkdiv_int_frac8(&c, clk_div, 0);

    // this makes fifo 8-deep
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}

%}
